const X = [
  "left_control",
  "left_shift",
  "left_option",
  "left_command",
  "right_control",
  "right_shift",
  "right_option",
  "right_command",
  "fn"
], ye = [
  ...X,
  "caps_lock"
], be = [
  "return_or_enter",
  "escape",
  "delete_or_backspace",
  "delete_forward",
  "tab",
  "spacebar",
  "hyphen",
  "equal_sign",
  "open_bracket",
  "close_bracket",
  "backslash",
  "non_us_pound",
  "semicolon",
  "quote",
  "grave_accent_and_tilde",
  "comma",
  "period",
  "slash",
  "non_us_backslash"
], ge = [
  "up_arrow",
  "down_arrow",
  "left_arrow",
  "right_arrow",
  "page_up",
  "page_down",
  "home",
  "end"
], ke = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z"
], we = [
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "0"
], ve = [
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "f10",
  "f11",
  "f12",
  "f13",
  "f14",
  "f15",
  "f16",
  "f17",
  "f18",
  "f19",
  "f20"
], Me = [
  "keypad_num_lock",
  "keypad_slash",
  "keypad_asterisk",
  "keypad_hyphen",
  "keypad_plus",
  "keypad_enter",
  "keypad_1",
  "keypad_2",
  "keypad_3",
  "keypad_4",
  "keypad_5",
  "keypad_6",
  "keypad_7",
  "keypad_8",
  "keypad_9",
  "keypad_0",
  "keypad_period",
  "keypad_equal_sign",
  "keypad_comma"
], Ce = [
  "print_screen",
  "scroll_lock",
  "pause",
  "insert",
  "application",
  "help",
  "power"
], Ae = [
  "international1",
  "international3",
  "lang1",
  "lang2"
], Ee = ["japanese_eisuu", "japanese_kana"], Ke = [
  "volume_down",
  // equal to `volume_decrement`
  "volume_up",
  // equal to `volume_increment`
  "mute",
  "volume_decrement",
  "volume_increment"
], F = [
  // Function keys
  "f21",
  "f22",
  "f23",
  "f24",
  // Keys in pc keyboards
  "execute",
  "menu",
  "select",
  "stop",
  "again",
  "undo",
  "cut",
  "copy",
  "paste",
  "find",
  // International keys
  "international2",
  "international4",
  "international5",
  "international6",
  "international7",
  "international8",
  "international9",
  "lang3",
  "lang4",
  "lang5",
  "lang6",
  "lang7",
  "lang8",
  "lang9",
  // Japanese
  "japanese_pc_nfer",
  // PCキーボードの無変換キー
  "japanese_pc_xfer",
  // PCキーボードの変換キー
  "japanese_pc_katakana",
  // PCキーボードのかなキー
  // Others
  "keypad_equal_sign_as400",
  "locking_caps_lock",
  "locking_num_lock",
  "locking_scroll_lock",
  "alternate_erase",
  "sys_req_or_attention",
  "cancel",
  "clear",
  "prior",
  "return",
  // rarely used return (HID usage 0x9e)
  "separator",
  "out",
  "oper",
  "clear_or_again",
  "cr_sel_or_props",
  "ex_sel"
], B = [
  // Disable this key
  "vk_none",
  // Others
  "vk_consumer_brightness_down",
  // equal to `display_brightness_decrement`
  "vk_consumer_brightness_up",
  // equal to `display_brightness_increment`
  "vk_mission_control",
  // equal to `mission_control`
  "vk_launchpad",
  // equal to `launchpad`
  "vk_dashboard",
  // equal to `dashboard`
  "vk_consumer_illumination_down",
  // equal to `illumination_decrement`
  "vk_consumer_illumination_up",
  // equal to `illumination_increment`
  "vk_consumer_previous",
  // equal to `rewind`
  "vk_consumer_play",
  // equal to `play`
  "vk_consumer_next",
  // equal to `fast_forward`
  "display_brightness_decrement",
  "display_brightness_increment",
  "rewind",
  "play_or_pause",
  "fastforward",
  "apple_display_brightness_decrement",
  "apple_display_brightness_increment",
  "dashboard",
  "launchpad",
  "mission_control",
  "apple_top_case_display_brightness_decrement",
  "apple_top_case_display_brightness_increment",
  "illumination_decrement",
  "illumination_increment"
], Mt = [
  // Media controls
  "rewind",
  "play_or_pause",
  "fast_forward",
  "mute",
  "volume_decrement",
  "volume_increment",
  "al_terminal_lock_or_screensaver",
  // Lock key on Magic Keyboard without Touch ID
  "eject",
  "scan_previous_track",
  "scan_next_track",
  // Application Launch keys
  "al_word_processor",
  "al_text_editor",
  "al_spreadsheet",
  "al_presentation_app",
  "al_email_reader",
  "al_calculator",
  "al_local_machine_browser",
  "al_internet_browser",
  "al_dictionary",
  // Others
  "fastforward"
], Ct = [
  // Media controls
  "menu",
  // Touch ID on Magic Keyboard
  // Application Launch keys
  "al_graphics_editor",
  "al_database_app",
  "al_newsreader",
  "al_voicemail",
  "al_contacts_or_address_book",
  "al_Calendar_Or_Schedule",
  "al_task_or_project_manager",
  "al_log_or_journal_or_timecard",
  "al_checkbook_or_finance",
  "al_a_or_v_capture_or_playback",
  "al_lan_or_wan_browser",
  "al_remote_networking_or_isp_connect",
  "al_network_conference",
  "al_network_chat",
  "al_telephony_or_dialer",
  "al_logon",
  "al_logoff",
  "al_logon_or_logoff",
  "al_control_panel",
  "al_command_line_processor_or_run",
  "al_process_or_task_manager",
  "al_select_task_or_application",
  "al_next_task_or_application",
  "al_previous_task_or_application",
  "al_preemptive_halt_task_or_application",
  "al_integrated_help_center",
  "al_documents",
  "al_thesaurus",
  "al_desktop",
  "al_spell_check",
  "al_grammer_check",
  "al_wireless_status",
  "al_keyboard_layout",
  "al_virus_protection",
  "al_encryption",
  "al_screen_saver",
  "al_alarms",
  "al_clock",
  "al_file_browser",
  "al_power_status",
  "al_image_browser",
  "al_audio_browser",
  "al_movie_browser",
  "al_digital_rights_manager",
  "al_digital_wallet",
  "al_instant_messaging",
  "al_oem_feature_browser",
  "al_oem_help",
  "al_online_community",
  "al_entertainment_content_browser",
  "al_online_shopping_browswer",
  "al_smart_card_information_or_help",
  "al_market_monitor_or_finance_browser",
  "al_customized_corporate_news_browser",
  "al_online_activity_browswer",
  "al_research_or_search_browswer",
  "al_audio_player",
  "al_message_status",
  "al_contact_sync",
  "al_navigation",
  "al_contextaware_desktop_assistant",
  // Generic GUI application Control keys
  "ac_home",
  "ac_back",
  "ac_forward",
  "ac_refresh",
  "ac_bookmarks",
  // Remote control buttons
  "menu_pick",
  "menu_up",
  "menu_down",
  "menu_left",
  "menu_right",
  "menu_escape",
  "menu_value_increase",
  "menu_value_decrease",
  "data_on_screen",
  "closed_caption",
  "closed_caption_select",
  "vcr_or_tv",
  "broadcast_mode",
  "snapshot",
  "still",
  "picture_in_picture_toggle",
  "picture_in_picture_swap",
  "red_menu_button",
  "green_menu_button",
  "blue_menu_button",
  "yellow_menu_button",
  "aspect",
  "three_dimensional_mode_select"
], At = [
  // Media controls
  "display_brightness_decrement",
  "display_brightness_increment",
  "dictation"
], Et = [
  "button1",
  "button2",
  "button3",
  "button4",
  "button5",
  "button6",
  "button7",
  "button8",
  "button9",
  "button10",
  "button11",
  "button12",
  "button13",
  "button14",
  "button15",
  "button16",
  "button17",
  "button18",
  "button19",
  "button20",
  "button21",
  "button22",
  "button23",
  "button24",
  "button25",
  "button26",
  "button27",
  "button28",
  "button29",
  "button30",
  "button31",
  "button32"
], L = {
  "⌘": "command",
  "⌥": "option",
  "⌃": "control",
  "⇧": "shift",
  "⇪": "caps_lock"
}, le = {
  "↑": "up_arrow",
  "↓": "down_arrow",
  "←": "left_arrow",
  "→": "right_arrow",
  "⇞": "page_up",
  "⇟": "page_down",
  "↖︎": "home",
  "↘︎": "end"
}, ue = {
  "⏎": "return_or_enter",
  "⎋": "escape",
  "⌫": "delete_or_backspace",
  "⌦": "delete_forward",
  "⇥": "tab",
  "␣": "spacebar",
  "-": "hyphen",
  "=": "equal_sign",
  "[": "open_bracket",
  "]": "close_bracket",
  "\\": "backslash",
  ";": "semicolon",
  "'": "quote",
  "`": "grave_accent_and_tilde",
  ",": "comma",
  ".": "period",
  "/": "slash"
}, te = {
  ...le,
  ...ue,
  "⇪": L["⇪"]
}, $e = [
  ...X,
  ...ye,
  ...be,
  ...ge,
  ...ke,
  ...we,
  ...ve,
  ...Me,
  ...Ce,
  ...Ae,
  ...Ee,
  ...Ke,
  ...F,
  ...B
];
function A(t, e, i) {
  if (typeof t == "number") return `${t}`;
  if (t.length > 1 && H(t)) {
    const n = Y(t);
    if ((n == null ? void 0 : n.length) === 1)
      return n[0];
    throw new Error(`Invalid key ${t}`);
  }
  if (t in te)
    return te[t];
  const o = t;
  if (!$e.includes(o))
    throw new Error(`${o} is not valid key_code`);
  if (e != null && e.includes(o))
    throw new Error(`Key ${t} cannot be used ${i || "here"}`);
  return o;
}
const Se = {
  Meh: ["option", "control", "shift"],
  Hyper: ["command", "option", "control", "shift"],
  SuperHyper: ["command", "option", "control", "shift", "fn"]
}, ie = {
  "⌘⇧": ["command", "shift"],
  "⌥⇧": ["option", "shift"],
  "⌃⇧": ["control", "shift"],
  "⌘⌥": ["command", "option"],
  "⌘⌃": ["command", "control"],
  "⌥⌃": ["option", "control"],
  "⌘⌥⌃": ["command", "option", "control"],
  "⌘⌥⇧": ["command", "option", "shift"],
  "⌘⌃⇧": ["command", "control", "shift"],
  "⌥⌃⇧": ["option", "control", "shift"],
  "⌘⌥⌃⇧": ["command", "option", "control", "shift"],
  ...Se
};
function E(t) {
  if (!t) return;
  if (typeof t == "string")
    return H(t) ? Y(t) : t in L ? [L[t]] : t in ie ? ie[t] : [t];
  if (Array.isArray(t))
    return Oe(t) ? je(t) : t.map(Pe);
  let e;
  "left" in t ? e = $("left", t.left) : "l" in t && (e = $("left", t.l));
  let i;
  if ("right" in t ? i = $("right", t.right) : "r" in t && (i = $("right", t.r)), !(!(e != null && e.length) && !(i != null && i.length)))
    return [...e || [], ...i || []];
}
const ce = /^(left|l|<|‹)([⌘⌥⌃⇧]*)$/, de = /^(right|r|>|›)([⌘⌥⌃⇧]*)$/;
function D(t, e) {
  if (!(!t && !e))
    return {
      mandatory: oe(t),
      optional: oe(e)
    };
}
function oe(t) {
  if (t)
    return t === "any" ? ["any"] : E(t);
}
const Te = /* @__PURE__ */ new Set([
  "command",
  "option",
  "control",
  "shift"
]);
function H(t) {
  return ce.test(t) || de.test(t);
}
function Y(t) {
  const e = t.match(ce);
  if (e)
    return $("left", e[2]);
  const i = t.match(de);
  if (i)
    return $("right", i[2]);
}
function Oe(t) {
  return t.some(H);
}
function je(t) {
  return t.reduce(
    (e, i) => [
      ...e,
      ...H(i) ? Y(i) || [] : E(i) || []
    ],
    []
  );
}
function $(t, e) {
  var i;
  if (e)
    return (i = E(e)) == null ? void 0 : i.map(
      (o) => Te.has(o) ? `${t}_${o}` : o
    );
}
function Pe(t) {
  return t in L ? L[t] : t;
}
function g(t) {
  return Array.isArray(t) ? t : [t];
}
function k(t, e = 1, i) {
  return new w({ type: "variable_if", name: t, value: e, description: i });
}
function Kt(t, e) {
  var o, n;
  let i;
  if (Array.isArray(t))
    i = t.map(R);
  else if (typeof t == "string" || t instanceof RegExp)
    i = [R(t)];
  else
    return new w({
      type: "frontmost_application_if",
      description: e,
      file_paths: (o = t.file_paths) == null ? void 0 : o.map(R),
      bundle_identifiers: (n = t.bundle_identifiers) == null ? void 0 : n.map(R)
    });
  return new w({
    type: "frontmost_application_if",
    description: e,
    bundle_identifiers: i
  });
}
function $t(t, e) {
  return new w({
    type: "device_if",
    identifiers: g(t),
    description: e
  });
}
function St(t, e) {
  return new w({
    type: "device_exists_if",
    identifiers: g(t),
    description: e
  });
}
function Tt(t, e) {
  return new w({
    type: "keyboard_type_if",
    keyboard_types: g(t),
    description: e
  });
}
function Ot(t, e) {
  return new w({
    type: "input_source_if",
    input_sources: g(t),
    description: e
  });
}
function jt(t = !0, e) {
  return new w({ type: "event_changed_if", value: t, description: e });
}
const Ve = Le({
  frontmost_application_if: "frontmost_application_unless",
  device_if: "device_unless",
  device_exists_if: "device_exists_unless",
  keyboard_type_if: "keyboard_type_unless",
  input_source_if: "input_source_unless",
  variable_if: "variable_unless",
  event_changed_if: "event_changed_unless"
});
class w {
  constructor(e) {
    this.condition = e;
  }
  /** Switch type {condition}_if to {condition}_unless, and vice versa */
  unless() {
    return new w({
      ...this.condition,
      type: Ve[this.condition.type]
    });
  }
  build() {
    return { ...this.condition };
  }
}
function De(t) {
  return typeof t.build == "function";
}
function K(t) {
  return De(t) ? t.build() : t;
}
function R(t) {
  return typeof t == "string" ? t : t.toString().slice(1, -1);
}
function Le(t) {
  return Object.keys(t).reduce(
    (e, i) => ({ ...e, [e[i]]: i }),
    t
  );
}
const Ne = ["optionalAny", "?any", "??"];
function Be(t) {
  return !t || typeof t != "string" ? !1 : Ne.includes(t);
}
function Ie(t) {
  return /^\?(left|l|<|‹|right|r|>|›)?([⌘⌥⌃⇧⇪]*)$/.test(t);
}
function y(t, e) {
  if (!t)
    return D(t, e);
  if (Be(t))
    return D("", "any");
  if (typeof t == "string") {
    if (Ie(t))
      return D(
        "",
        E(t.slice(1))
      );
    if (t.startsWith("?"))
      throw new Error(`${t} is not valid optional alias`);
  }
  return typeof t == "object" && "optional" in t ? D("", t.optional) : D(t, e);
}
function N(t, e, i) {
  if (typeof t == "object")
    return new O(t);
  const o = A(
    t,
    B,
    "for from.key_code"
  );
  return new O({
    key_code: o,
    modifiers: y(e, i)
  });
}
function Pt(t, e, i) {
  return new O({
    consumer_key_code: t,
    modifiers: y(e, i)
  });
}
function Vt(t, e, i) {
  return new O({
    pointing_button: t,
    modifiers: y(e, i)
  });
}
function h(t, e, i) {
  const o = A(
    t,
    F,
    "as to.key_code"
  );
  return {
    ...i,
    key_code: o,
    modifiers: e ? E(e) : void 0
  };
}
function qe(t) {
  return h("left_command", "⌥⌃⇧", t);
}
function Re(t) {
  return h("left_option", "⌃⇧", t);
}
function xe(t) {
  return h("fn", "⌘⌥⌃⇧", t);
}
function Ue(t) {
  return h("vk_none", void 0, t);
}
function Fe(t, e, i) {
  return {
    ...i,
    consumer_key_code: t,
    modifiers: e ? E(e) : void 0
  };
}
function He(t, e, i) {
  return {
    ...i,
    pointing_button: t,
    modifiers: e ? E(e) : void 0
  };
}
function J(t) {
  return { shell_command: t };
}
function Je(t) {
  const e = t.match(/^"?(.*?)(.app)?"?$/);
  return J(`open -a "${(e == null ? void 0 : e[1]) || t}".app`);
}
function We(t) {
  return J(`osascript -e '
set prev to the clipboard
set the clipboard to "${t}"
tell application "System Events"
  keystroke "v" using command down
  delay 0.1
end tell
set the clipboard to prev'`);
}
const ze = [
  "Tink",
  "Submarine",
  "Sosumi",
  "Morse",
  "Ping",
  "Pop",
  "Purr",
  "Glass",
  "Hero",
  "Frog",
  "Funk",
  "Blow",
  "Bottle",
  "Basso"
];
function Dt(t) {
  const e = ze.includes(t) ? `/System/Library/Sounds/${t}.aiff` : t;
  return J(`afplay ${e}`);
}
function Ge(t) {
  return { select_input_source: t };
}
function f(t, e = 1, i, o) {
  return { set_variable: { name: t, value: e, key_up_value: i, type: o } };
}
function Qe(t) {
  return { set_variable: { name: t, type: "unset" } };
}
function _e(t, e) {
  return { set_notification_message: { id: t, text: e } };
}
function W(t) {
  return { set_notification_message: { id: t, text: "" } };
}
function Xe(t) {
  return { mouse_key: t };
}
function Ye(t, e = "toggle") {
  return { sticky_modifier: { [t]: e } };
}
function Ze(t) {
  return {
    software_function: { cg_event_double_click: { button: t } }
  };
}
function et(t) {
  return { software_function: { set_mouse_cursor_position: t } };
}
function tt(t) {
  return {
    software_function: {
      iokit_power_management_sleep_system: { delay_milliseconds: t }
    }
  };
}
const T = {};
for (let t = 0; t <= 9; t++)
  T[t] = h(t);
const it = "abcdefghijklmnopqrstuvwxyz".split("");
for (const t of it)
  T[t] = h(t), T[t.toUpperCase()] = h(t, "⇧");
const ot = [
  ...Object.keys(le),
  ...Object.keys(ue)
];
for (const t of ot)
  T[t] = h(t);
const nt = {
  1: "!",
  2: "@",
  3: "#",
  4: "$",
  5: "%",
  6: "^",
  7: "&",
  8: "*",
  9: "(",
  0: ")",
  "'": '"',
  "=": "+",
  ";": ":",
  ",": "<",
  ".": ">",
  "/": "?",
  "-": "_",
  "[": "{",
  "\\": "|",
  "]": "}",
  "`": "~"
};
for (const [t, e] of Object.entries(nt))
  T[e] = h(t, "⇧");
function rt(t, e) {
  return t.split("").map((i) => {
    const o = (e == null ? void 0 : e[i]) || T[i];
    if (!o)
      throw new Error(
        `${i} is unknown. Please provide a map with { ${i}: {ToEvent} }`
      );
    return o;
  });
}
class O {
  constructor(e) {
    this.manipulator = { type: "basic", from: e };
  }
  /** The FromEvent of the Manipulator. */
  get from() {
    return this.manipulator.from;
  }
  to(e, i, o) {
    return this.addToEvent(
      typeof e == "object" ? e : h(e, i, o)
    ), this;
  }
  /** To Hyper key ⌘⌥⌃⇧ */
  toHyper(e) {
    return this.addToEvent(qe(e)), this;
  }
  /** To Meh key ⌥⌃⇧ */
  toMeh(e) {
    return this.addToEvent(Re(e)), this;
  }
  /** To SuperHyper key ⌘⌥⌃⇧fn */
  toSuperHyper(e) {
    return this.addToEvent(xe(e)), this;
  }
  /** To vk_none (Disable this key) */
  toNone(e) {
    return this.addToEvent(Ue(e)), this;
  }
  /** To { consumer_key_code } */
  toConsumerKey(e, i, o) {
    return this.addToEvent(Fe(e, i, o)), this;
  }
  /** Map to mouse button */
  toPointingButton(e, i, o) {
    return this.addToEvent(He(e, i, o)), this;
  }
  /** Map to shell command */
  to$(e) {
    return this.addToEvent(J(e)), this;
  }
  /** Map to `$ open -a {app}.app` */
  toApp(e) {
    return this.addToEvent(Je(e)), this;
  }
  /** Map to paste {text} via clipboard */
  toPaste(e) {
    return this.addToEvent(We(e)), this;
  }
  /** To change the current input source */
  toInputSource(e) {
    return this.addToEvent(Ge(e)), this;
  }
  /** Map to setting a variable */
  toVar(e, i = 1, o, n) {
    return this.addToEvent(f(e, i, o, n)), this;
  }
  /** Map to unsetting a variable */
  toUnsetVar(e) {
    return this.addToEvent(Qe(e)), this;
  }
  /** To set or remove (set text to '') the notification message */
  toNotificationMessage(e, i) {
    return this.addToEvent(_e(e, i)), this;
  }
  /** To remove the notification message */
  toRemoveNotificationMessage(e) {
    return this.addToEvent(W(e)), this;
  }
  /** Move mouse cursor by delta */
  toMouseKey(e) {
    return this.addToEvent(Xe(e)), this;
  }
  /** Changes to a sticky modifier key */
  toStickyModifier(e, i = "toggle") {
    return this.addToEvent(Ye(e, i)), this;
  }
  /** @see https://karabiner-elements.pqrs.org/docs/json/complex-modifications-manipulator-definition/to/software_function/cg_event_double_click/ */
  toCgEventDoubleClick(e) {
    return this.addToEvent(Ze(e)), this;
  }
  /** Set mouse cursor position */
  toMouseCursorPosition(e) {
    return this.addToEvent(et(e)), this;
  }
  /** To causes a system sleep */
  toSleepSystem(e) {
    return this.addToEvent(tt(e)), this;
  }
  /** To type a string of keys */
  toTypeSequence(e, i) {
    return this.addToEvent(rt(e, i)), this;
  }
  toIfAlone(e, i, o) {
    return this.pushOrCreateList(
      this.manipulator,
      "to_if_alone",
      typeof e == "object" ? e : h(e, i, o)
    ), this;
  }
  toIfHeldDown(e, i, o) {
    return this.pushOrCreateList(
      this.manipulator,
      "to_if_held_down",
      typeof e == "object" ? e : h(e, i, o)
    ), this;
  }
  toAfterKeyUp(e, i, o) {
    return this.pushOrCreateList(
      this.manipulator,
      "to_after_key_up",
      typeof e == "object" ? e : h(e, i, o)
    ), this;
  }
  toDelayedAction(e, i) {
    const o = this.manipulator.to_delayed_action || {
      to_if_invoked: [],
      to_if_canceled: []
    };
    return g(e).forEach((n) => o.to_if_invoked.push(n)), g(i).forEach((n) => o.to_if_canceled.push(n)), this.manipulator.to_delayed_action = o, this;
  }
  description(e) {
    return this.manipulator.description = e, this;
  }
  condition(...e) {
    const { conditions: i = [] } = this.manipulator;
    return this.manipulator.conditions = [...i, ...e.map(K)], this;
  }
  parameters(e) {
    return this.manipulator.parameters = { ...this.manipulator.parameters, ...e }, this;
  }
  build(e) {
    return [{ ...this.manipulator }];
  }
  addToEvent(e) {
    this.pushOrCreateList(this.manipulator, "to", e);
  }
  pushOrCreateList(e, i, o) {
    const n = e[i] || [];
    g(o).forEach((r) => n.push(r)), Object.assign(e, { [i]: n });
  }
}
function st(t) {
  return typeof t.build == "function";
}
function j(t, e) {
  return st(t) ? t.build(e) : "type" in t ? [t] : Object.entries(t).reduce(
    (o, [n, r]) => [...o, ...N(n).to(r).build(e)],
    []
  );
}
function Lt(...t) {
  return (e) => {
    const i = t.map(K);
    function o(s) {
      return s.type !== "basic" ? s : {
        ...s,
        conditions: [...s.conditions || [], ...i]
      };
    }
    const r = (Array.isArray(e) ? e : j(e)).reduce(
      (s, u) => [...s, ...j(u).map(o)],
      []
    );
    return Object.assign(r, { build: () => r });
  };
}
function Nt(t) {
  return (e) => ({
    build: () => (Array.isArray(t) ? t.map((o, n) => [o, n]) : Object.entries(t)).reduce(
      (o, [n, r]) => [...o, ...j(e(n, r))],
      []
    )
  });
}
function Bt(t, e) {
  return (i) => ({
    build: (o) => {
      const n = y(
        t,
        e
      );
      return (Array.isArray(i) ? i : j(i)).map((s) => j(s, o)).reduce((s, u) => s.concat(u), []).map((s) => {
        var a;
        const u = Object.keys(n).reduce(
          (l, c) => {
            var d;
            if (!((d = n[c]) != null && d.length)) return l;
            const p = /* @__PURE__ */ new Set([
              ...l[c] || [],
              ...n[c]
            ]);
            return l[c] = p.has("any") ? ["any"] : Array.from(p), l;
          },
          { ...(a = s.from) == null ? void 0 : a.modifiers }
        );
        return s.from = { ...s.from, modifiers: u }, s;
      });
    }
  });
}
function at(t, e, i) {
  const o = (r) => A(r, B, "for from.simultaneous"), n = new lt({
    simultaneous: t.map(
      (r) => typeof r == "object" ? r : { key_code: o(r) }
    ),
    simultaneous_options: e
  });
  return i && n.parameters({
    "basic.simultaneous_threshold_milliseconds": i
  }), n;
}
class lt extends O {
  constructor(e) {
    super(e);
  }
  modifiers(e, i) {
    return this.manipulator.from.modifiers = e || i ? y(e, i) : void 0, this;
  }
}
const fe = "__support__manipulator";
function ut(t) {
  return t.description = (t.description || "") + fe, t;
}
function Z(t) {
  var e;
  return (e = t.description) == null ? void 0 : e.endsWith(fe);
}
const ne = {
  "double_tap.delay_milliseconds": 200
};
function It(t, e, i, o) {
  const n = A(
    t,
    [...F, ...B],
    "for double tap"
  ), r = new ct({ key_code: n });
  return o ? (r.delay(o), r.from.modifiers = y(
    e,
    i
  )) : i ? typeof i == "number" ? (r.delay(i), r.from.modifiers = y(
    e
  )) : r.from.modifiers = y(
    e,
    i
  ) : e && (typeof e == "number" ? r.delay(e) : r.from.modifiers = y(
    e
  )), r;
}
class ct extends O {
  constructor(e) {
    super(e), this.singleTapEvent = void 0;
  }
  /** Set single tap which is from key by default; null to disable */
  singleTap(e) {
    return this.singleTapEvent = e, this;
  }
  /** Set the delay parameter */
  delay(e) {
    return this.delayParam = e, this;
  }
  build(e) {
    var p;
    const i = (e == null ? void 0 : e.getParameters(ne)) ?? ne, o = this.delayParam || i["double_tap.delay_milliseconds"], n = this.from.key_code;
    if (this.singleTapEvent === void 0) {
      this.singleTapEvent = { key_code: n };
      const d = (p = this.manipulator.from.modifiers) == null ? void 0 : p.mandatory;
      d && (this.singleTapEvent.modifiers = d.filter(
        (M) => M !== "any"
      ));
    }
    const r = ["double-tap", n];
    this.from.modifiers && [this.from.modifiers.mandatory, this.from.modifiers.optional].map((d) => d != null && d.length ? d.join(",") : "").forEach((d) => d && r.push(d));
    const s = r.join("-"), u = k(s).build(), a = k(s).unless().build(), l = ut({
      ...this.manipulator,
      conditions: [u]
    }), c = {
      ...this.manipulator,
      to: [f(s, 1)],
      conditions: [...this.manipulator.conditions || [], a],
      to_delayed_action: {
        to_if_invoked: [
          ...this.singleTapEvent ? [this.singleTapEvent] : [],
          f(s, 0)
        ],
        to_if_canceled: [f(s, 0)]
      }
    };
    return c.parameters = {
      "basic.to_delayed_action_delay_milliseconds": o
    }, [l, c];
  }
}
function qt() {
  return new dt();
}
class dt {
  constructor() {
    this.manipulator = {
      type: "mouse_motion_to_scroll"
    };
  }
  modifiers(e, i) {
    return this.manipulator.from = {
      modifiers: y(
        e,
        i
      )
    }, this;
  }
  condition(...e) {
    const { conditions: i = [] } = this.manipulator;
    return this.manipulator.conditions = [...i, ...e.map(K)], this;
  }
  options(e) {
    return this.manipulator.options = { ...this.manipulator.options, ...e }, this;
  }
  build(e) {
    return [{ ...this.manipulator }];
  }
}
function Rt(t, ...e) {
  return new z(t, ...e);
}
class z {
  constructor(e, ...i) {
    this.ruleDescription = e, this.manipulatorSources = [], this.allowEmptyManipulators = !1, this.conditions = i;
  }
  manipulators(e) {
    return Array.isArray(e) ? e.forEach((i) => this.manipulatorSources.push(i)) : this.manipulatorSources.push(e), this;
  }
  condition(...e) {
    return e.forEach((i) => this.conditions.push(i)), this;
  }
  description(e) {
    return this.ruleDescription = e, this;
  }
  build(e) {
    const i = {
      description: this.ruleDescription,
      manipulators: this.manipulatorSources.reduce(
        (n, r) => [...n, ...j(r, e)],
        []
      )
    };
    if (!this.allowEmptyManipulators && i.manipulators.length === 0)
      throw new Error(`"manipulators" is empty in "${i.description}"`);
    if (this.conditions.length === 0) return i;
    const o = this.conditions.map(K);
    return i.manipulators = i.manipulators.map(
      (n) => n.type === "basic" && !Z(n) ? { ...n, conditions: [...n.conditions || [], ...o] } : { ...n }
    ), i;
  }
}
function _t(t) {
  return typeof t.build == "function";
}
function ft(t, e) {
  return _t(t) ? t.build(e) : t;
}
const U = {
  escape: ["escape", "caps_lock"]
};
function pe(t, e, i) {
  const o = [];
  if (!t) return o;
  for (const n of Array.isArray(t) ? t : [t]) {
    const r = N(n);
    o.push(...r.condition(e).to(i).build());
  }
  return o;
}
const Q = [
  ...B,
  ...F,
  ...X
];
function pt(t, e, i = 1, o = 0) {
  return new mt(t, e, i, o);
}
function ht(t, e, i, o = 1, n = 0) {
  return pt(e, i, o, n).modifiers(t);
}
function xt(t, e, i = 1, o = 0) {
  return ht("Hyper", t, e, i, o);
}
const x = "__layer";
class mt extends z {
  constructor(e, i, o = 1, n = 0) {
    const r = g(e).map(
      (s) => A(s, Q, "as layer key")
    );
    i || (i = `layer-${r.join("-")}`), super(`Layer - ${i}`), this.onValue = o, this.offValue = n, this.replaceLayerKeyToIfAlone = !1, this.keys = r, this.varName = i, this.layerCondition = k(this.varName, this.onValue), this.condition(this.layerCondition), this.allowEmptyManipulators = !0;
  }
  modifiers(e, i) {
    return this.layerModifiers = e || i ? y(e, i) : void 0, this;
  }
  /** Config the layer key. */
  configKey(e, i = !1) {
    return this.layerKeyManipulator || (this.layerKeyManipulator = N("fn")), e(this.layerKeyManipulator), this.replaceLayerKeyToIfAlone = i, this;
  }
  /** Set the notification when the layer is active. */
  notification(e = !0) {
    return this.layerNotification = e, this;
  }
  /** Set leader mode. Default escape keys: ['escape', 'caps_lock']. */
  leaderMode(e = !0) {
    return e === !0 ? this.leaderModeOptions = U : e ? this.leaderModeOptions = { ...U, ...e } : this.leaderModeOptions = void 0, this;
  }
  build(e) {
    var n, r, s, u;
    const i = super.build(e);
    if (this.leaderModeOptions) {
      const a = [
        f(this.varName, this.offValue),
        f(x, 0)
      ];
      this.layerNotification && a.push(W(me(this.varName))), this.leaderModeOptions.sticky || i.manipulators.forEach(
        (l) => l.type === "basic" && !Z(l) && (l.to = (l.to || []).concat(a))
      ), i.manipulators.push(
        ...pe(
          this.leaderModeOptions.escape,
          k(this.varName, this.onValue),
          a
        )
      );
    }
    if ((r = (n = this.layerModifiers) == null ? void 0 : n.mandatory) != null && r.length || (u = (s = this.layerModifiers) == null ? void 0 : s.optional) != null && u.length) {
      const a = re(this.layerModifiers) === "optional";
      i.manipulators.forEach(
        (l) => this.addModifierAnyToManipulator(l, a)
      );
    }
    const o = this.conditions.filter((a) => a !== this.layerCondition).map(K);
    for (const a of this.keys)
      i.manipulators = [
        ...he(
          a,
          this.varName,
          this.onValue,
          this.offValue,
          this.layerModifiers,
          o,
          e,
          this.layerKeyManipulator,
          this.replaceLayerKeyToIfAlone,
          this.layerNotification === !0 ? this.ruleDescription : this.layerNotification || void 0,
          this.leaderModeOptions
        ),
        ...i.manipulators
      ];
    return i;
  }
  // If the layer has modifiers, set manipulator modifiers to { mandatory: ['any'] }
  addModifierAnyToManipulator(e, i) {
    if (e.type === "basic") {
      if (e.from.modifiers) {
        const { mandatory: o, optional: n } = e.from.modifiers;
        if (n != null && n.length || o != null && o.length) {
          const r = re(e.from.modifiers);
          if (r === "mandatory")
            e.from.modifiers = { mandatory: ["any"] };
          else if (r === "optional")
            e.from.modifiers = { optional: ["any"] };
          else
            throw new Error(
              "Layers with modifiers cannot have modifiers on manipulators"
            );
          return;
        }
      }
      e.from.modifiers = i ? { optional: ["any"] } : { mandatory: ["any"] };
    }
  }
}
function he(t, e, i, o, n, r, s, u, a, l, c) {
  var V;
  function p(_) {
    var ee;
    if (!u) return _;
    const m = u.build()[0], C = g(_)[0];
    if ([
      "to",
      "to_if_alone",
      "to_if_held_down",
      "to_after_key_up"
    ].forEach(
      (v) => {
        var I;
        return (I = m[v]) == null ? void 0 : I.forEach(
          (q) => C[v] = [...C[v] || [], q]
        );
      }
    ), m.to_delayed_action) {
      C.to_delayed_action = C.to_delayed_action || {
        to_if_invoked: [],
        to_if_canceled: []
      };
      for (const v of ["to_if_invoked", "to_if_canceled"])
        m.to_delayed_action[v].forEach(
          (I) => {
            var q;
            return (q = C.to_delayed_action) == null ? void 0 : q[v].push(I);
          }
        );
    }
    return a && (C.to_if_alone = (ee = C.to_if_alone) == null ? void 0 : ee.filter(
      (v) => !("key_code" in v && v.key_code === t)
    )), _;
  }
  const d = N({ key_code: t, modifiers: n }).toVar(e, i).toVar(x).condition(k(e, i).unless(), k(x).unless());
  if (!((V = n == null ? void 0 : n.mandatory) != null && V.length) && !c && d.toIfAlone({ key_code: t }), c || d.toAfterKeyUp(f(e, o)).toAfterKeyUp(f(x, 0)), r != null && r.length && d.condition(...r), l) {
    const _ = me(e);
    d.toNotificationMessage(_, l), c || d.toAfterKeyUp(W(_));
  }
  if (!s)
    return p(d.build());
  const M = [
    `layer_${t}`,
    ...n ? [JSON.stringify(n)] : [],
    ...(r || []).map((_) => JSON.stringify(_)).sort()
  ].join("_"), b = s.getCache(M);
  if (b != null && b.to && b.to_after_key_up)
    return b.to.find(
      (m) => "set_variable" in m && m.set_variable.name === e
    ) || (b.to.push(f(e, i)), b.to_after_key_up.push(f(e, o))), p(b), [];
  const P = d.build(s);
  return s.setCache(M, P[0]), p(P);
}
function re({
  mandatory: t,
  optional: e
}) {
  return (t == null ? void 0 : t.length) === 1 && t[0] === "any" ? "mandatory" : (e == null ? void 0 : e.length) === 1 && e[0] === "any" ? "optional" : null;
}
function me(t) {
  return `layer-${t}`;
}
const se = {
  "simlayer.threshold_milliseconds": 200
};
function Ut(t, e, i, o = 1, n = 0) {
  return new yt(t, e, i, o, n);
}
class yt extends z {
  constructor(e, i, o, n = 1, r = 0) {
    const s = g(e).map(
      (u) => A(u, Q, "as simlayer key")
    );
    i || (i = `simlayer-${s.join("-")}`), super(`Simlayer - ${i}`), this.threshold = o, this.onValue = n, this.offValue = r, this.sharedLayerKeys = [], this.simultaneousOptions = {
      detect_key_down_uninterruptedly: !0,
      key_down_order: "strict",
      key_up_order: "strict_inverse",
      key_up_when: "any"
    }, this.layerModifiers = { optional: ["any"] }, this.ifActivated = [], this.ifDeactivated = [], this.keys = s, this.varName = i, this.layerCondition = k(this.varName, this.onValue), this.condition(this.layerCondition);
  }
  modifiers(e, i) {
    return this.layerModifiers = e || i ? y(e, i) : void 0, this;
  }
  /** Set simultaneous_options on the simlayer toggle manipulator */
  options(e) {
    return Object.assign(this.simultaneousOptions, e), this;
  }
  /** Enable layer with the same variable and manipulators with this simlayer */
  enableLayer(...e) {
    return e.map(
      (i) => A(i, Q, "as layer key")
    ).forEach((i) => {
      if (this.keys.includes(i))
        throw new Error(`Key ${i} is already used in ${this.ruleDescription}`);
      if (this.sharedLayerKeys.includes(i))
        throw new Error(
          `Key ${i} is already used as shared layer key in  ${this.ruleDescription}`
        );
      this.sharedLayerKeys.push(i);
    }), this;
  }
  /** The ToEvents to trigger when the layer is activated */
  toIfActivated(e) {
    return this.ifActivated.push(e), this;
  }
  /** The ToEvents to trigger when the layer is deactivated */
  toIfDeactivated(e) {
    return this.ifDeactivated.push(e), this;
  }
  build(e) {
    const i = super.build(e), o = (e == null ? void 0 : e.getParameters(se)) ?? se, n = this.threshold || o["simlayer.threshold_milliseconds"], r = this.conditions.length > 1 ? this.conditions.filter((a) => a !== this.layerCondition).map(K) : void 0, s = f(this.varName, this.onValue), u = f(this.varName, this.offValue);
    i.manipulators.concat().forEach((a) => {
      var c;
      if (a.type !== "basic")
        throw new Error(
          `Unsupported manipulator type ${a.type} in simlayer ${this.ruleDescription}`
        );
      const l = (c = a.from) == null ? void 0 : c.key_code;
      if (!l)
        throw new Error(
          `Missing from.key_code in simlayer ${this.ruleDescription}`
        );
      this.layerModifiers && (a.from.modifiers = {
        ...a.from.modifiers,
        ...this.layerModifiers
      });
      for (const p of this.keys)
        i.manipulators.push({
          type: "basic",
          parameters: {
            "basic.simultaneous_threshold_milliseconds": n
          },
          to: [s, ...a.to || [], ...this.ifActivated],
          from: {
            simultaneous: [{ key_code: p }, { key_code: l }],
            simultaneous_options: {
              ...this.simultaneousOptions,
              to_after_key_up: [
                ...this.simultaneousOptions.to_after_key_up || [],
                u,
                ...this.ifDeactivated
              ]
            },
            modifiers: this.layerModifiers
          },
          conditions: r
        });
    });
    for (const a of this.sharedLayerKeys)
      i.manipulators = [
        ...he(
          a,
          this.varName,
          this.onValue,
          this.offValue,
          this.layerModifiers,
          r,
          e
        ),
        ...i.manipulators
      ];
    return i;
  }
}
const ae = {
  "duo_layer.threshold_milliseconds": 200,
  "duo_layer.notification": !1
};
function Ft(t, e, i, o = 1, n = 0) {
  return new bt(t, e, i, o, n);
}
class bt extends z {
  constructor(e, i, o, n = 1, r = 0) {
    const s = `DuoLayer ${o || `${e} ${i}`}`;
    o || (o = `duo-layer-${e}-${i}`), super(s), this.key1 = e, this.key2 = i, this.onValue = n, this.offValue = r, this.simultaneousOptions = {}, this.ifActivated = [], this.ifDeactivated = [], this.varName = o, this.layerCondition = k(this.varName, this.onValue), this.condition(this.layerCondition), this.allowEmptyManipulators = !0;
  }
  threshold(e) {
    return this.simultaneousThreshold = e, this;
  }
  options(e) {
    return Object.assign(this.simultaneousOptions, e), this;
  }
  /** Set the notification when the layer is active. */
  notification(e = !0) {
    return this.layerNotification = e, this;
  }
  /** The ToEvents to trigger when the layer is activated */
  toIfActivated(e) {
    return this.ifActivated.push(e), this;
  }
  /** The ToEvents to trigger when the layer is deactivated */
  toIfDeactivated(e) {
    return this.ifDeactivated.push(e), this;
  }
  /** Set leader mode. Default escape keys: ['escape', 'caps_lock']. */
  leaderMode(e = !0) {
    return e === !0 ? this.leaderModeOptions = U : e ? this.leaderModeOptions = { ...U, ...e } : this.leaderModeOptions = void 0, this;
  }
  build(e) {
    var M, b, P, V;
    const i = super.build(e), o = (e == null ? void 0 : e.getParameters(ae)) ?? ae, n = this.simultaneousThreshold || o["duo_layer.threshold_milliseconds"], r = this.layerNotification ?? o["duo_layer.notification"], s = this.conditions.filter((_) => _ !== this.layerCondition).map(K), u = [f(this.varName, this.onValue), ...this.ifActivated], a = [
      f(this.varName, this.offValue),
      ...this.ifDeactivated
    ];
    if (r) {
      const _ = `duo-layer-${this.varName}`, m = r === !0 ? this.ruleDescription : r;
      u.push(_e(_, m)), a.push(W(_));
    }
    this.leaderModeOptions && (this.leaderModeOptions.sticky || i.manipulators.forEach(
      (_) => _.type === "basic" && !Z(_) && (_.to = (_.to || []).concat(a))
    ), i.manipulators.push(
      ...pe(
        this.leaderModeOptions.escape,
        k(this.varName, this.onValue),
        a
      )
    ));
    const l = this.simultaneousOptions.to_after_key_up || [];
    this.leaderModeOptions || l.push(...a);
    const c = at(
      [this.key1, this.key2],
      {
        ...this.simultaneousOptions,
        to_after_key_up: l
      },
      n
    ).modifiers("??").to(u).condition(k(this.varName, this.onValue).unless());
    if (s.length && c.condition(...s), !e)
      return i.manipulators = [...c.build(), ...i.manipulators], i;
    const p = [
      `duo_layer_${this.key1}_${this.key2}`,
      ...s.map((_) => JSON.stringify(_)).sort()
    ].join("_"), d = e.getCache(p);
    if (d)
      ((M = d.to) == null ? void 0 : M.find(
        (m) => "set_variable" in m && m.set_variable.name === this.varName
      )) || ((b = d.to) == null || b.push(f(this.varName, this.onValue)), (V = (P = d.from.simultaneous_options) == null ? void 0 : P.to_after_key_up) == null || V.push(
        f(this.varName, this.offValue)
      ));
    else {
      const _ = c.build(e)[0];
      e.setCache(p, _), i.manipulators = [_, ...i.manipulators];
    }
    return i;
  }
}
class gt {
  constructor() {
    this.parameters = {}, this.cache = /* @__PURE__ */ new Map();
  }
  setParameters(e) {
    Object.assign(this.parameters, e);
  }
  getParameters(e) {
    const i = { ...e };
    for (const o of Object.keys(e))
      o in this.parameters && this.parameters[o] !== void 0 && Object.assign(i, { [o]: this.parameters[o] });
    return i;
  }
  getCache(e) {
    return this.cache.get(e);
  }
  setCache(e, i) {
    this.cache.set(e, i);
  }
}
const kt = {
  "basic.to_if_alone_timeout_milliseconds": 1e3,
  "basic.to_if_held_down_threshold_milliseconds": 500,
  "basic.to_delayed_action_delay_milliseconds": 500,
  "basic.simultaneous_threshold_milliseconds": 50,
  "mouse_motion_to_scroll.speed": 100
};
function wt(t, e = {}) {
  const {
    "double_tap.delay_milliseconds": i,
    "simlayer.threshold_milliseconds": o,
    "duo_layer.threshold_milliseconds": n,
    "duo_layer.notification": r,
    ...s
  } = e, u = new gt();
  u.setParameters({
    "double_tap.delay_milliseconds": i
  }), u.setParameters({
    "simlayer.threshold_milliseconds": o
  }), u.setParameters({
    "duo_layer.threshold_milliseconds": n,
    "duo_layer.notification": r
  });
  const a = t.map((c) => ft(c, u)), l = {
    rules: a.filter((c) => c.manipulators.length),
    parameters: {
      ...kt,
      ...s
    }
  };
  if (l.rules.length === 0)
    throw new Error('complex_modifications "rules" is empty ');
  return l.rules.length < a.length && console.warn(`Rules with empty manipulators are ignored: 
${a.filter((c) => c.manipulators.length === 0).map((c) => "- " + c.description).join(`
`)}
`), l;
}
const S = {
  karabinerConfigDir() {
    return require("node:path").join(
      require("node:os").homedir(),
      ".config/karabiner"
    );
  },
  karabinerConfigFile() {
    return require("node:path").join(
      this.karabinerConfigDir(),
      "karabiner.json"
    );
  },
  readKarabinerConfig(t) {
    return require(t ?? this.karabinerConfigFile());
  },
  writeKarabinerConfig(t, e) {
    return require("node:fs/promises").writeFile(
      e ?? this.karabinerConfigFile(),
      t
    );
  },
  readJson(t) {
    return require(t);
  },
  exit(t = 0) {
    process.exit(t);
  }
};
function Ht(t, e, i = {}) {
  typeof t == "string" && (t = { name: t, dryRun: t === "--dry-run" });
  const { name: o, dryRun: n } = t, r = t.karabinerJsonPath ?? S.karabinerConfigFile(), s = n ? { profiles: [{ name: o, complex_modifications: { rules: [] } }] } : S.readKarabinerConfig(r), u = s == null ? void 0 : s.profiles.find((l) => l.name === o);
  u || G(`⚠️ Profile ${o} not found in ${r}.

ℹ️ Please check the profile name in the Karabiner-Elements UI and 
    - Update the profile name at writeToProfile()
    - Create a new profile if needed
 `);
  try {
    u.complex_modifications = wt(e, i);
  } catch (l) {
    G(l);
  }
  const a = JSON.stringify(s, null, 2);
  if (n) {
    console.info(a);
    return;
  }
  S.writeKarabinerConfig(a, r).catch(G), console.log(`✓ Profile ${o} updated.`);
}
function G(t) {
  return t && console.error(typeof t == "string" ? t : t.message || t), S.exit(1);
}
function Jt(t) {
  return {
    build() {
      const e = S.readJson(t);
      if (!Array.isArray(e == null ? void 0 : e.rules))
        throw new Error(`Cannot file rules in ${t}`);
      return {
        description: `Imported from ${t}`,
        manipulators: e.rules.reduce(
          (i, o) => i.concat(o.manipulators),
          []
        )
      };
    }
  };
}
function Wt(t, e) {
  return {
    build() {
      const o = S.readKarabinerConfig(e).profiles.find((n) => n.name === t);
      if (!o) throw new Error(`Profile ${t} not found`);
      return {
        description: `Imported from profile ${t}`,
        manipulators: o.complex_modifications.rules.reduce(
          (n, r) => n.concat(r.manipulators),
          []
        )
      };
    }
  };
}
export {
  w as ConditionBuilder,
  le as arrowKeyAliases,
  ge as arrowKeyCodes,
  K as buildCondition,
  wt as complexModifications,
  ue as controlOrSymbolKeyAliases,
  be as controlOrSymbolKeyCodes,
  kt as defaultComplexModificationsParameters,
  ne as defaultDoubleTapParameters,
  ae as defaultDuoLayerParameters,
  se as defaultSimlayerParameters,
  Ft as duoLayer,
  Mt as fromAndToConsumerKeyCodes,
  Ct as fromOnlyConsumerKeyCodes,
  F as fromOnlyKeyCodes,
  ve as functionKeyCodes,
  A as getKeyWithAlias,
  xt as hyperLayer,
  Kt as ifApp,
  $t as ifDevice,
  St as ifDeviceExists,
  jt as ifEventChanged,
  Ot as ifInputSource,
  Tt as ifKeyboardType,
  k as ifVar,
  Jt as importJson,
  Wt as importProfile,
  Ae as internationalKeyCodes,
  De as isConditionBuilder,
  H as isSideMultiModifierAlias,
  Ee as japaneseKeyCodes,
  Me as keypadKeyCodes,
  pt as layer,
  ke as letterKeyCodes,
  N as map,
  Pt as mapConsumerKey,
  It as mapDoubleTap,
  Vt as mapPointingButton,
  at as mapSimultaneous,
  L as modifierKeyAliases,
  ye as modifierKeyCodes,
  ht as modifierLayer,
  qt as mouseMotionToScroll,
  ie as multiModifierAliases,
  Se as namedMultiModifierAliases,
  we as numberKeyCodes,
  Ke as otherKeyCodes,
  D as parseFromModifierParams,
  E as parseModifierParam,
  Y as parseSideMultiModifierAlias,
  Ce as pcKeyboardKeyCodes,
  Et as pointingButtons,
  Rt as rule,
  Ut as simlayer,
  X as stickyModifierKeyCodes,
  ze as systemSounds,
  J as to$,
  Je as toApp,
  Ze as toCgEventDoubleClick,
  Fe as toConsumerKey,
  qe as toHyper,
  Ge as toInputSource,
  h as toKey,
  Re as toMeh,
  et as toMouseCursorPosition,
  Xe as toMouseKey,
  Ue as toNone,
  _e as toNotificationMessage,
  At as toOnlyConsumerKeyCodes,
  B as toOnlyKeyCodes,
  We as toPaste,
  Dt as toPlaySound,
  He as toPointingButton,
  W as toRemoveNotificationMessage,
  f as toSetVar,
  tt as toSleepSystem,
  Ye as toStickyModifier,
  xe as toSuperHyper,
  rt as toTypeSequence,
  Qe as toUnsetVar,
  Lt as withCondition,
  Nt as withMapper,
  Bt as withModifier,
  Ht as writeToProfile
};
